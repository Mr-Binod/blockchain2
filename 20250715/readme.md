# 계정 추상화 ERC-4337 account abstraction


> 계정 추상화는 외 사옹을 할까?
> 기존의 이더리움 네트워크 사용자 계정은 두가지로 분류가 되는데
> 이더리움 네트워크의 상태를 저장할때 형태가 두가지

## EOA계정과 CA

> EOA 계정은 개인키로 제어가 가능하다. 소유주의 판단이 가능 서명도 만들수 있다. (트랜잭션을 발생)
> 상태 값이나 코드의 값을 사용할수 없슴 => 커스텀이 불가능하다.

> CA 는 스마트 계약의 코드를 제어하기 위해서 다중 서명같은 복잡한 플랫품 로직을 제공하기 위한 계정
> 제약은 트랜잭션을 발생 시킬수 없다. 대신에 상태변수나 코드의 영역을 다뤄서 커스텀이 가능하다.


### 문제점 
> 소셜 로그인 같은 편의성 ux의 제공이 힘들기 때문에 스마트 컨트랙트 지갑을 활용하면 어떨까?

> EOA 는 확장성과 보안의 기능을 더 추가로 제공하기에는 무리가 있다. 기존의 구조를 옆지않는 이상
> 추상화된 계정을 사용하면 새로 WEB3 상태계에 유입되는 사용자들도 어려움 없이 웹 3 의 상태계를 경험할수 있다. => 개인키의 유무를 몰라도 웹3의 상태계를 경험하는데 무리가 없다.
> 지갑을 잃어벼려도 복구를 할수 있는 계정 

### 이더리움 네트워크 지갑의 구조

> EOA 사용자 지갑
> 20 바이트 주소의 문자열로 표현해서 사용
- 속성
1. NONCE : 계정의 트랜잭션 횟수
2. BALANCE : 계정의 잔액
3. STORAGEROOT : 상태 저장소 트리의 루트 해시값
4. CODEHASH : 컨트랙트 코드의 해시 

> EOA의 생성은 개인키를 가지고 공개키를 만들어서 주소를 생성 => 가스비를 지불
> CA 는 트랜잭션을 통해서 바이너리코드를 배포할때 주소를 생성 => 가스비를 지불 X


### 기존 트랜잭션의 형태 
1. EOA 계정으로 서명을 해서 트랜잭션 생성
2. 노드를 통해서 네트워크에 P2P 전파 evm에서 상태 저장
3. 검증 이후 체인에 추가되면 블록에 기록된 내용이 된다.
4. 가스비 수수료 지불


#### 4337의 기존 문제점 해결
1. 사용자가 EOA 계정을 사용할때 개인키를 안전하게 보관하지 않으면 지갑이 분실
2. 가스비 부담 => 페이 마스터가 관리 => 가스리스 서버로 대처
3. 스마트 지갑을 구현했다. => 기존 EOA의 형태의 제한을 해결해서 CA를 계정으로 확장시켰다.
4. 스마트 지갑을 사용해서 개인키를 소유하는 하드웨어 지갑의 사용성의 한계점을 극복
5. NONCE 트랜잭션의 횟수 이중지불 방지를 위해서 사용하는 값ㅇ르 병렬처리 할수 있는 구조로 만들었다


#### ERC 4337의 핵심 구조
1. UserOperation : 유저의 요청 정보의 형태 
2. EntryPoint : 컨트랙트에서 유저의 요청 정보를 검증하고 노드에 전파하는 컨트랙트 => handleOps
3. SmartAccount : CA로 생성한 커스텀된 유저의 계정 역활을 하는 컨트랙트
4. Bundler : UserOperation의 내용을 모아서 일정 시간 혹은 일정 갯수에 트랜잭션을 EntryPoint로 요청 보낼수 있는 구조 백엔드 => 번들러 수수료가 UserOperation에 포함되어 있다
5. Paymaster : 가스비 후원 지불자 유저에게 가스비를 대신 대납해준다

### UserOperation 내용
1. sender : 스마트 계정의 주소 트랜잭션을 호출하고싶은 스마트 계정
2. nonce : 이중지불 방지에 사용하는 숫자 엄버 스마트 계정에서 상태변수로 관리를 하기때문에 EOA의 한계를 극복해서 병렬로 트랜잭션을 처리할수 있다
3. initCode : 스마트 계정이 아직 배포가 되지않으면 배포를 하기위한 바이트 코드 => 컨트랙트가 생성된 이후에는 내용이 없으면 0x 한번이라도 계정으로 작업을 신청했으면 계정이 이미 있는것
4. callData : 스마트 계정이 실행할 작업의 직접적인 내용 바이트코드가 포함된다 => 함수 이름과 매개변수를 해시화해서 컨트랙트의 상태변수를 변경하는 함ㅅ의 내용을 호출할 작업의 내용이 포함되어있는 속성
5. callGasLimit : callData 의 가스비 제한을 하는 량
6. verificationGasLimit : 스마트 계정의 서명 검증 실행할때 가스 한도. 
7. preVerifiCationGas : Bundler 에서 userOps들을 포함한 가스의 초과를 방지하기위한 충량 가스 callData 가스량과 EntryPointㅇ의 가스량을 계산해서 제한
8. masFeePerGas : EIP-1559 basefee  기본 수수료와 번들러에게 제공할 tip을 가지고 전체 량을 제한
9. maxPriorityFeePerGas : Bundler에게 제공할 가스 수수료 tip의 량 번들러에서 트랜잭션의 우성순위 결정에 영향을 주는 값
10. paymasterAndData : 대납자의 주소가 포함 조건의 내용 등
11. signature : UserOperation 내용을 검증하는 서명값 => 다중서명등 서명의 내용을 확장시킬수 있다.


### 서명 구조와 검증 제안
> 기존의 이더리움 네트워크에서 서명 개인키로 서명을 하는 내용이 UserOperation signature => 대납자가 있다면 단순히 서명을 검증하는 역활만 하는값이다 => 서명의 검증엣만 가스 지불은 대납자 즉 여기서 이더리움 네투워크에서 네이티브 트랜잭션에서 처리되는 서명은 대납자의 서명 스마트 계정의 서명 즉 UserOperation signature 값은 컨트랙트에서 검증으로만 사용을 한다. 검증방식을 확장시킬수 있다.
ValidateUserOp() => 스마트 계정의 서명을 검증하는 함수 => 실제 검증은 컨트랙트 내부에서 일어난다.
> EIP-1271 : 컨트랙트에서 서명을 검증하는 방식의 제안 => 컨트랙트내에서 rsv 값을 가지고 복원하는 방식
> 서명은 네이트브 evm에서 동작하는 검증의 내용이 아닌 유저가 전달한 UserOperation 의 안정성을 검증하는 로직

> validateuserOp에서 서명을 검증하면서 스마트 계정의 저장소에 상태를 저장 nonce의 값이 상태로 저장된다.
> 컨트랙트의 내부에서 nonce를 확장성있게 커스텀의 형태로 다룰수 있는 특징 => 큰 장점중에 하나


#### 전체 흐름

1. 유저 (프론트엔드) => 지갑 (예 : 소셜 로그인) -> 개인키 생성 -> 스마트 계정 생성(UserOperation) -> 스마트 계정 생성
2. UserOperation -> Bundler(백엔드 서버) 의 트랜잭션 풀에 생성 -> UserOperation들을 한번에 일정 시간 혹은 갯수를 가지고 -> entryPoint에 요청 (대납자)
3. UserOps[] -> entrypoint 에서 검증하는 로직 호출 -> validateUserOp 함수를 호출해서 서명 검증
4. 스마트 계정 컨트랙트 -> calldata 의 내용을 execute -> execute대리 호출 -> 내부 트랜잭션으로 로그를남기고 호룿이 된다
5. execute => 대리호출이 일어나는 시점 => 스마트 계정의 로직 실행











